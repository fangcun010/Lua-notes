debug.getinfo([thread],f,[what])

返回一个带有函数信息的表。我们可以直接使用函数作为参数，也可以给一个
表示函数在堆栈中层级的数字，0表示当前函数(getinfo函数本身)。
1代表调用getinfo的函数(排除掉尾调用，因为尾调用利用了同一栈帧来进行函数调用。)
，其余依此类推。如果f的值大于当前栈帧中的函数数量，getinfo会返回nil。

返回的表可以包含lua_getinfo函数返回的所有域，
我们可以使用what参数来选择需要填充的域。
缺省情况下，函数返回除了有效行外的所有可用信息。
'f'选项会添加一个叫做func的域名来存放这个函数本身。
'L'选项会添加一个叫做activelines的域来存放函数的有效行。

举个例子，debug.getinfo(1,"n").name会返回当前函数的名称，如果它存在一个可用
的名字，debug.getinfo(print)会返回一个表，里面包含了print函数的所有可用
信息。

lua_getinfo

int lua_getinfo(lua_State *L,const char *what,lua_Debug *ar)

获取指定函数或函数调用的信息。

为了获取函数调用信息必须保证cr参数是一个有效的活动记录，
它被lua_getstack函数填充或是一个挂钩的参数。

为了获取函数信息，需要将函数压入栈中，并且它的what参数需要以'>'开始。
(在这种情况下，lua_getinfo函数会把函数从栈顶弹出。)
想要知道函数f定义了哪些代码，我们可以使用下面这些代码：

	lua_Debug ar;
	lua_getlobal(L,"f");
	lua_getinfo(L,">s",&ar);
	printf("%d\n",ar.linedefined);

what参数

'n':填充name域和namewhat域。
'S':填充source,short_src,linedefined,lastlinedefined和what。
'l':填充currentline域。
't':填充istailcall域。
'u':填充nups,nparams,和isvararg域。
'f':把给定层级的函数压入栈中。
'L':把函数的有效行压入栈中。(有效行表示存在代码的行，这些行可以被放置断点。
无效行通常是空行和注释。)

和'f'一块使用的选项，它的表在函数后被压入栈中。

这个函数在遇到错误时会返回0。(比如使用了不合法的what参数时)。
